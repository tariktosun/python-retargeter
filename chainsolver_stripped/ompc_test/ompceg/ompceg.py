"""OMPC extension generator.

ompceg.py [FNAME]

  FNAME - .c or .cpp file

"""

import ompc

__AUTHOR__ = ompc.AUTHOR

MFUNC = \
"""function %(ret_def)s%(fname)s(%(mparams)s)
%(doc)s
%(signature)s
    %(ret_val)scalllib('%(libname)s','%(fname)s'%(ppass)s);

"""

SIGNATURE = \
"""% Generated by ompc extension generator v%s
% by %s, 2007, %s
"""%(__VERSION__, __AUTHOR__, ompc.OMPC_URL)

def docs(d,p):
    """Generate documentation string for m-file."""
    doc =['%%   %(ret_def)s%(FNAME)s(%(mparams)s)'%p,
          '%%'%p]
    for x in  d.split('\n'):
        doc += [ re.sub(r'^\s*/(?:/|\*)\s*','% ', x) ]
    if not doc[-1].strip():
        del doc[-1]
    return '\n'.join(doc)

def ret_val(r, params):
    """Determine the return values."""
    rets = []
    if 'void' not in r:
        rets += ['libreturn']
    for x in params:
        if 'out' in x[0]:
            rets += [x[2]]
    res_def = ''
    if len(rets) == 1:
        res_def = '%s = '%rets[0]
    elif len(rets) > 1:
        res_def = '[%s] = '%', '.join(rets)
    #return res_def, 'void' not in r and 'libreturn = ' or ''
    return res_def, res_def

def main():
    import sys, os, re
    if len(sys.argv) < 2:
        print __doc__
        sys.exit()
    
    fname = sys.argv[1]
        
    a = open(fname,'rt').read()
    rc = re.compile(r'API\s+(\w+)\s+([^\s\(]+)\(([^\)]*)\).*?\n(.*?)\n?\{',re.S|re.M)
    #rp = re.compile(r'^(/\*[^\*]*\*/|)\s*(.*?)\s*([\w_\[\]\\d]+)$',re.S|re.M)
    rp = re.compile(r'(?:\s*?/\*\s*\[([^\]]+)\]\s*\*/|)\s*(.*?)\s*([\w_\[\]\\d]+)(?:,|$)',re.S|re.M)
    
    pth, fname = os.path.split(fname)
    fname, fext = os.path.splitext(fname)
    
    omcp.mkdir('lib%s'%fname)
    
    head = []
    for r,n,p,d in rc.findall(a):
        head += ['%s %s(%s);'%(r,n,p)]
        ps = rp.findall(p)
        mparams = ', '.join([ x[2] for x in ps ])
        ppass = ''
        if mparams:
            ppass = ', ' + mparams;
        rd, rv = ret_val(r, ps)
        dc = dict(ret_def=rd, ret_val=rv, fname=n, FNAME=n.upper(), params=p, 
                  mparams=mparams, ppass=ppass, libname=fname)
        doc = docs(d,dc)
        dc.update(doc=doc, signature=SIGNATURE)
        open('lib%s/%s.m'%(fname,n),'wt').write(MFUNC%dc)
    
    open('%s.h'%fname,'wt').write('\n'.join(head)+'\n')

if __name__ == "":
    main()
